# -*- coding: utf-8 -*-
"""Production_master.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LJw73DGoP0RDXiOoy8q9R_a9CyrNUT9n
"""

from google.colab import drive
drive.mount('/content/drive')

import os, glob
from IPython.display import display

BASE = "/content/drive/MyDrive/Capstone Project/Data"

# INPUTS (edit if your folders differ)
PROD_DIR_B  = f"{BASE}/preprocess/html-processing/preprocessed-data/Breakfast production"
PROD_DIR_L  = f"{BASE}/preprocess/html-processing/preprocessed-data/Lunch production"
SCHOOLS_CSV = f"{BASE}/preprocess/school-processing/preprocessed-data/schools preprocess.csv"

# OUTPUTS
PROC_DIR   = f"{BASE}/processed"
OUT_MASTER = f"{PROC_DIR}/fact_production.csv"
OUT_ONE    = f"{PROC_DIR}/combined/fact_meal_day.csv"
os.makedirs(os.path.dirname(OUT_ONE), exist_ok=True)

print("Breakfast CSVs:", len(glob.glob(os.path.join(PROD_DIR_B, "*.csv"))))
print("Lunch CSVs    :", len(glob.glob(os.path.join(PROD_DIR_L, "*.csv"))))
print("Schools CSV   :", os.path.exists(SCHOOLS_CSV))

import re, numpy as np, pandas as pd, os

def parse_num(x):
    if x is None: return np.nan
    s = str(x).strip()
    if s == "": return np.nan
    pct = s.endswith("%")
    if pct: s = s[:-1]
    neg = s.startswith("(") and s.endswith(")")
    s = s.replace("$","").replace(",","").replace("(","").replace(")","")
    try:
        v = float(s)
        if neg: v = -v
        return v*100 if pct else v
    except:
        return np.nan

def fix_code(x):
    s = str(x or "").strip()
    if s.endswith(".0") and s[:-2].isdigit(): s = s[:-2]
    s = re.sub(r"[^\d]","",s)
    return s if len(s)>3 else (s.zfill(3) if s else "")

def norm_meal(s):
    s = str(s or "").strip().upper()
    b_tokens = ("BREAK", "BFAST", "B'FAST", "BRKF", "BRKFT", "BRKFST", "BRK", "BF")
    l_tokens = ("LUNCH", "LNCH", "LCH", "LN")
    if any(tok in s for tok in b_tokens): return "Breakfast"
    if any(tok in s for tok in l_tokens):  return "Lunch"
    return "Unknown"

def norm_name(s: str) -> str:
    s = (s or "").upper()
    s = s.replace("ELEMENTARY SCHOOL","ES").replace("ELEMENTARY","ES")
    s = s.replace("MIDDLE SCHOOL","MS").replace("MIDDLE","MS")
    s = s.replace("HIGH SCHOOL","HS").replace("HIGH","HS")
    s = re.sub(r"\bSCHOOL\b", "", s)
    s = re.sub(r"[^A-Z0-9 ]+", " ", s)
    s = re.sub(r"\s+", " ", s).strip()
    return s

def simplify(s: str) -> str:
    return re.sub(r'[^a-z0-9]', '', str(s).lower())

def find_cols(df, must_have=(), any_of=()):
    out=[]
    for c in df.columns:
        sc=simplify(c)
        if all(tok in sc for tok in must_have) and (not any_of or any(tok in sc for tok in any_of)):
            out.append(c)
    return out

def sum_by(df, must_have=(), any_of=()):
    cols=find_cols(df, must_have, any_of)
    if not cols:
        return pd.Series([0.0]*len(df), index=df.index, dtype='float64')
    s = pd.Series(0.0, index=df.index, dtype='float64')
    for c in cols:
        s = s + pd.to_numeric(df[c].apply(parse_num), errors='coerce').fillna(0.0)
    return s

def load_prod_csv_v2(path, meal_hint=None):
    df = pd.read_csv(path, dtype=str)
    df.rename(columns={c: c.strip() for c in df.columns}, inplace=True)

    # Date
    date_col=None
    for cand in df.columns:
        sc=simplify(cand)
        if sc in ("date","servicedate","servicedt"):
            date_col=cand; break
    df['Date'] = pd.to_datetime(df[date_col], errors='coerce') if date_col else pd.NaT

    # Meal (override Unknown with folder hint)
    meal_col=None
    for cand in df.columns:
        sc=simplify(cand)
        if sc in ("meal","mealtype","mealperiod"):
            meal_col=cand; break
    if meal_col:
        m = df[meal_col].apply(norm_meal)
        if meal_hint:
            m = np.where(m=="Unknown", meal_hint, m)
        df['Meal'] = m
    else:
        low = os.path.basename(path).lower()
        df['Meal'] = norm_meal(meal_hint or ('Breakfast' if 'breakfast' in low else ('Lunch' if 'lunch' in low else 'Unknown')))

    # School name / code
    name_col=None
    for cand in df.columns:
        sc=simplify(cand)
        if sc in ("schoolname","sitename","school"):
            name_col=cand; break
    df['School_Name'] = df[name_col].astype(str).str.strip() if name_col else ""
    df['School_Name_norm'] = df['School_Name'].apply(norm_name)

    code_col=None
    for cand in df.columns:
        sc=simplify(cand)
        if sc in ("schoolcode","sitecode","code"):
            code_col=cand; break
    df['School_Code'] = df[code_col] if code_col else ""

    # Build totals from split columns (reimb/nonreimb)
    planned = sum_by(df, ("planned",), ("total",))
    if planned.fillna(0).eq(0).all():
        planned = sum_by(df, ("planned","reimb"),()) + sum_by(df, ("planned","nonreimb"),())
    df['Planned_Total'] = planned

    offered = sum_by(df, ("offered",), ("total",))
    if offered.fillna(0).eq(0).all():
        offered = sum_by(df, ("offered","reimb"),()) + sum_by(df, ("offered","nonreimb"),())
    df['Offered_Total'] = offered

    served = sum_by(df, ("served",), ("total",))
    if served.fillna(0).eq(0).all():
        served = sum_by(df, ("served","reimb"),()) + sum_by(df, ("served","nonreimb"),())
        if served.fillna(0).eq(0).all():
            left = sum_by(df, ("leftover",), ("total","qty","quantity"))
            disc = sum_by(df, ("discard",), ("total","qty","quantity","count"))
            served = (offered.fillna(0) - left.fillna(0) - disc.fillna(0)).clip(lower=0)
    df['Served_Total'] = served

    # Waste parts (optional)
    df['Leftover_Total']  = sum_by(df, ("leftover",), ("total","qty","quantity"))
    df['Discarded_Total'] = sum_by(df, ("discard",), ("total","qty","quantity","count"))

    # Costs per line → aggregate later
    cost_line = sum_by(df, ("subtotal",), ("cost","$"))
    if cost_line.fillna(0).eq(0).all():
        cost_line = sum_by(df, ("cost","line"), ())
    if cost_line.fillna(0).eq(0).all():
        pcs = find_cols(df, ("production","cost","total"), ())
        if pcs:
            tmp = pd.Series(0.0, index=df.index, dtype='float64')
            for c in pcs:
                tmp = tmp + pd.to_numeric(df[c].apply(parse_num), errors='coerce').fillna(0.0)
            cost_line = tmp
    df['Production_Cost_Line'] = cost_line

    disc_cost_line = sum_by(df, ("discard","cost"), ())
    df['Discarded_Cost_Line'] = disc_cost_line if not disc_cost_line.fillna(0).eq(0).all() else 0.0

    keep = ['School_Name','School_Name_norm','School_Code','Date','Meal',
            'Planned_Total','Offered_Total','Served_Total',
            'Discarded_Total','Leftover_Total',
            'Production_Cost_Line','Discarded_Cost_Line']
    for c in keep:
        if c not in df.columns: df[c] = np.nan
    return df[keep]

assert os.path.exists(SCHOOLS_CSV), f"Missing schools CSV at {SCHOOLS_CSV}"
sch = pd.read_csv(SCHOOLS_CSV, dtype=str)

sch['School_Code']      = sch.get('School_Code','').apply(fix_code)
sch['School_Name']      = sch.get('School_Name','').astype(str).str.strip()
sch['School_Name_norm'] = sch['School_Name'].apply(norm_name)

dim_cols = [c for c in ['Region','Region_Num','School_Level','Pyramid',
                        'Distribution_Kitchen','FNS_Area','CEP','Enrollment']
            if c in sch.columns]
sch_keep = sch[['School_Code','School_Name_norm','School_Name'] + dim_cols].drop_duplicates()

print("Schools rows:", len(sch_keep), "| Dim cols:", dim_cols)
display(sch_keep.head(5))

parts=[]
for fp in sorted(glob.glob(os.path.join(PROD_DIR_B, "*.csv"))):
    parts.append(load_prod_csv_v2(fp, meal_hint="Breakfast"))
for fp in sorted(glob.glob(os.path.join(PROD_DIR_L, "*.csv"))):
    parts.append(load_prod_csv_v2(fp, meal_hint="Lunch"))

assert parts, "No production CSVs found in Breakfast/Lunch folders."
prod = pd.concat(parts, ignore_index=True)
print("Raw production rows:", len(prod))
display(prod.head(5))

prod['School_Code']      = prod['School_Code'].apply(fix_code)
prod['School_Name_norm'] = prod['School_Name_norm'].fillna('').astype(str)

# Fill missing codes from schools by normalized name
prod = prod.merge(
    sch_keep[['School_Name_norm','School_Code']].rename(columns={'School_Code':'School_Code_from_name'}),
    on='School_Name_norm', how='left'
)
prod['School_Code'] = np.where(prod['School_Code'].astype(str).str.strip()=="",
                               prod['School_Code_from_name'], prod['School_Code'])
prod.drop(columns=['School_Code_from_name'], inplace=True)

# finalize
prod['Date'] = pd.to_datetime(prod['Date'], errors='coerce').dt.date
prod['Meal'] = prod['Meal'].apply(norm_meal)

print("Code coverage after fill:",
      f"{(prod['School_Code'].astype(str).str.strip()!='').mean():.1%}")
missing_keys = prod[prod['School_Code'].eq("") | prod['Date'].isna() | (prod['Meal']=="Unknown")]
print("Rows with missing critical keys:", len(missing_keys))
display(prod.head(5))

# Aggregate totals (sum per day/meal)
key_cols = ['School_Code','Date','Meal']
num_cols = [c for c in ['Served_Total','Offered_Total','Planned_Total',
                        'Discarded_Total','Leftover_Total',
                        'Production_Cost_Line','Discarded_Cost_Line']
            if c in prod.columns]
agg = (prod.groupby(key_cols, as_index=False)[num_cols].sum(min_count=1))
agg.rename(columns={
    'Production_Cost_Line':'Production_Cost_Total',
    'Discarded_Cost_Line':'Discarded_Cost_Total'
}, inplace=True)

# Attach name by code (best effort from production)
names_from_prod = prod[['School_Code','School_Name']].dropna().drop_duplicates()
agg = agg.merge(names_from_prod, on='School_Code', how='left')

# ---- attach dimensions: code-first
dim_cols_present = [c for c in ['Region','Region_Num','School_Level','Pyramid',
                                'Distribution_Kitchen','FNS_Area','CEP','Enrollment']
                    if c in sch_keep.columns]
by_code = sch_keep[['School_Code','School_Name'] + dim_cols_present].drop_duplicates()
agg = agg.merge(by_code, on='School_Code', how='left', suffixes=('','_bycode'))

# ---- name-fallback
agg['School_Name_norm'] = agg['School_Name'].fillna("").apply(norm_name)
by_name = sch_keep[['School_Name_norm','School_Code','School_Name'] + dim_cols_present].drop_duplicates()
agg = agg.merge(by_name.add_suffix('_byname'),
                left_on='School_Name_norm', right_on='School_Name_norm_byname', how='left')

fill_cols = ['School_Code','School_Name'] + dim_cols_present
for c in fill_cols:
    src = f"{c}_byname"
    if src in agg.columns:
        agg[c] = np.where(agg[c].isna() | (agg[c]==""), agg[src], agg[c])

drop_cols = [c for c in agg.columns if c.endswith('_bycode') or c.endswith('_byname')]
agg.drop(columns=drop_cols + [col for col in ['School_Name_norm_byname'] if col in agg.columns],
         inplace=True, errors='ignore')

print("Dim coverage:")
for col in ['School_Name','Region','School_Level','Pyramid']:
    if col in agg.columns:
        print(f"  {col}: {(~agg[col].isna() & (agg[col].astype(str).str.strip()!='')).mean():.1%}")

display(agg.head(10))

served  = pd.to_numeric(agg.get('Served_Total'), errors='coerce')
offered = pd.to_numeric(agg.get('Offered_Total'), errors='coerce')
planned = pd.to_numeric(agg.get('Planned_Total'), errors='coerce')
costtot = pd.to_numeric(agg.get('Production_Cost_Total'), errors='coerce')
disc    = pd.to_numeric(agg.get('Discarded_Total'), errors='coerce')
left    = pd.to_numeric(agg.get('Leftover_Total'), errors='coerce')

agg['Cost_per_Meal']        = np.where((served>0) & (~costtot.isna()), costtot/served, np.nan)
agg['Deviation_vs_Planned'] = np.where(~planned.isna(), served - planned, np.nan)
agg['Waste_Qty']            = np.where(~disc.isna() & (disc>0), disc,
                                np.where(~left.isna() & (left>0), left,
                                         np.where((~offered.isna()) & (~served.isna()), (offered-served).clip(lower=0), np.nan)))
agg['Waste_Rate']           = np.where((~offered.isna()) & (offered>0), agg['Waste_Qty']/offered, np.nan)

# Optional extra metric if you kept discarded cost
if 'Discarded_Cost_Total' in agg.columns:
    agg['Discarded_Cost_per_Meal'] = np.where(served>0, agg['Discarded_Cost_Total']/served, np.nan)

display(agg[['School_Name','Date','Meal','Served_Total','Offered_Total',
             'Production_Cost_Total','Cost_per_Meal','Deviation_vs_Planned',
             'Waste_Qty','Waste_Rate']].head(12))

agg = agg.sort_values(['School_Name','Date','Meal'])

agg.to_csv(OUT_MASTER, index=False)
agg.to_csv(OUT_ONE, index=False)

print("✅ Wrote master:", OUT_MASTER)
print("✅ Wrote one-table:", OUT_ONE)
print("Rows:", len(agg),
      "| Schools:", agg['School_Code'].nunique(),
      "| Dates:", agg['Date'].min(), "→", agg['Date'].max())
print("\nColumns:", list(agg.columns))

