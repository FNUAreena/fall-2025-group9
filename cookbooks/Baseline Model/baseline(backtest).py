# -*- coding: utf-8 -*-
"""Baseline(Backtest).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XYL6Vk6Tb2rO-k9eqNOx9Ox3BubsPcie
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np

df= pd.read_csv('/content/drive/MyDrive/Capstone Project/Data/preprocess Data/combined_breakfast_lunch.csv', low_memory=False)

same_weekday_occurence = 4
last_anyday_occurence = 10
offered_ratio = (1.00, 1.50)

def to_date(date):
  return pd.to_datetime(date, errors="coerce")

def money_to_float(s: pd.Series) -> pd.Series:
    s = s.astype(str).str.strip()
    s = s.str.replace(r"\((.*)\)", r"-\1", regex=True)
    s = s.str.replace(r"[$,]", "", regex=True)
    return pd.to_numeric(s, errors="coerce")

def winsorize_by_group(df, group_cols, col, q_lo=0.01, q_hi=0.99, fallback=(0.05,0.95)):
    output = df.copy()
    def _clip(g):
        x = g[col].dropna()
        if len(x) >= 40:
            lo, hi = x.quantile(q_lo), x.quantile(q_hi)
        elif len(x) >= 15:
            lo, hi = x.quantile(fallback[0]), x.quantile(fallback[1])
        else:
            return g
        g[col] = g[col].clip(lower=lo, upper=hi)
        return g
    return output.groupby(group_cols, group_keys=False).apply(_clip)

def rolling_median_values(s, k):
    return s.shift(1).rolling(k, min_periods=1).median()

def wmape(y_true, y_pred):
    num = np.abs(y_true - y_pred).sum()
    den = max(float(y_true.sum()), 1.0)
    return float(num/den)

required_columns = ["date","school_name","session","served_total","offered_total","subtotal_cost","left_over_cost","production_cost_total"]
missing_column = [c for c in required_columns if c not in df.columns]
if missing_column:
    raise ValueError(f"Missing required columns: {missing_column}")

df["date"] = to_date(df["date"])
df["session"] = df["session"].astype(str).str.title()
df["school_name"] = df["school_name"].astype(str)
df["school_name"] = df["school_name"].astype(str).str.strip()
df["session"]     = df["session"].astype(str).str.strip().str.title()

for rows in ["served_total","offered_total"]:
    df[rows] = pd.to_numeric(df[rows], errors="coerce")

for rows in ["subtotal_cost","left_over_cost","discarded_cost","production_cost_total"]:
    df[rows] = money_to_float(df[rows])

daily_cpm = (df.groupby(["school_name","date","session"], as_index=False)
           .agg(served_total=("served_total","sum"),
                offered_total=("offered_total","sum"),
                subtotal_cost=("subtotal_cost","sum"),
                left_over_cost=("left_over_cost","sum"),
                discarded_cost=("discarded_cost","sum"),
                production_cost_total=("production_cost_total","sum")))

daily_cpm["dow"] = daily_cpm["date"].dt.day_name()
iso = daily_cpm["date"].dt.isocalendar()
daily_cpm["iso_week"] = iso.week.astype(int)
daily_cpm["iso_year"] = iso.year.astype(int)
daily_cpm["month"] = daily_cpm["date"].dt.month

daily_cpm["waste_cost"] = daily_cpm["left_over_cost"].fillna(0) + daily_cpm["discarded_cost"].fillna(0)
daily_cpm["CPM"] = np.where(daily_cpm["served_total"]>0, daily_cpm["production_cost_total"]/daily_cpm["served_total"], np.nan)
daily_cpm["offered_ratio"] = np.where(daily_cpm ["served_total"]>0, daily_cpm["offered_total"]/daily_cpm["served_total"], np.nan)
daily_cpm["offered_ratio"] = daily_cpm["offered_ratio"].clip(*offered_ratio)

g_day = daily_cpm.groupby(["school_name","date"])
daily_cpm["closure_flag"]   = (g_day["served_total"].transform("sum")==0) & (g_day["offered_total"].transform("sum")==0)
daily_cpm["full_waste_day"] = (daily_cpm["served_total"]==0) & (daily_cpm["offered_total"]>0)

daily_winsorize = winsorize_by_group(daily_cpm, ["school_name","session"], "CPM")

daily_winsorize.describe(include='all')

daily_winsorize.columns

daily_cpm.describe()

cols_same = [
    "school_name","date","session","served_total","offered_total",
    "subtotal_cost","left_over_cost","discarded_cost",
    "production_cost_total","waste_cost",
    "dow","iso_week","iso_year","month",
    "closure_flag","full_waste_day"
]

print("All identical columns equal? ->", daily_winsorize[cols_same].equals(daily_cpm[cols_same]))

cpm_changed = (daily_cpm["CPM"].notna()) & (daily_winsorize["CPM"].notna()) & (daily_winsorize["CPM"] != daily_cpm["CPM"])
print("CPM values clipped (winsorized):", int(cpm_changed.sum()))

ratio_changed = (daily_cpm["offered_ratio"].notna()) & (daily_winsorize["offered_ratio"].notna()) & (daily_winsorize["offered_ratio"] != daily_cpm["offered_ratio"])
print("offered_ratio values clipped:", int(ratio_changed.sum()))

daily_winsorize = daily_winsorize.sort_values(['school_name','session','date']).reset_index(drop=True)

for var in ["served_total","CPM","waste_cost","offered_ratio"]:
    daily_winsorize[f"{var}_day_of_week_baseline"] = (daily_winsorize.groupby(["school_name","session","dow"])[var]
                                   .transform(lambda s: rolling_median_values(s, same_weekday_occurence)))
    daily_winsorize[f"{var}_anyday_baseline"] = (daily_winsorize.groupby(["school_name","session"])[var]
                                   .transform(lambda s: rolling_median_values(s, last_anyday_occurence)))
    daily_winsorize[f"{var}_final_baseline"] = np.where(daily_winsorize[f"{var}_day_of_week_baseline"].notna(),
                                    daily_winsorize[f"{var}_day_of_week_baseline"], daily_winsorize[f"{var}_anyday_baseline"])

daily_winsorize["offered_ratio_final_baseline"] = daily_winsorize["offered_ratio_final_baseline"].clip(*offered_ratio)

daily_winsorize.columns

pairs = (daily_winsorize[["school_name","session"]]
         .dropna()
         .drop_duplicates()
         .sort_values(["school_name","session"]))
print("Unique schoolÃ—session pairs:", len(pairs))
print(pairs.head(50))
print(
    daily_winsorize.groupby(["school_name","session"], as_index=False)
           .size()
           .sort_values("size", ascending=False)
           .head(50)
)

bt = daily_winsorize.copy()
mask_have_bl = bt["served_total_final_baseline"].notna()
mask_served  = mask_have_bl & (~bt["closure_flag"]) & (bt["served_total"]>0)

rows = []
for (sch, ses), g in bt.groupby(["school_name","session"]):
    gs = g[mask_served & (g["school_name"]==sch) & (g["session"]==ses)]
    served_wmape = (abs(gs["served_total"] - gs["served_total_final_baseline"]).sum() /
                    max(gs["served_total"].sum(), 1)) if len(gs)>0 else np.nan

    gc = g[mask_have_bl & g["CPM"].notna() & g["CPM_final_baseline"].notna()]
    cpm_mae = float(np.abs(gc["CPM"] - gc["CPM_final_baseline"]).mean()) if len(gc)>0 else np.nan

    gw = g[mask_have_bl & g["waste_cost"].notna() & g["waste_cost_final_baseline"].notna()]
    wastecost_mae = float(np.abs(gw["waste_cost"] - gw["waste_cost_final_baseline"]).mean()) if len(gw)>0 else np.nan

    go = g[mask_have_bl & g["offered_ratio_final_baseline"].notna() & g["served_total_final_baseline"].notna()]
    if len(go)>0:
        offered_pred = np.ceil(go["offered_ratio_final_baseline"] * go["served_total_final_baseline"])
        waste_meals  = np.clip(offered_pred - go["served_total"], 0, None)
        stock_meals  = np.clip(go["served_total"] - offered_pred, 0, None)
        waste_per_100 = float(100 * waste_meals.sum() / max(go["served_total"].sum(),1))
        stock_rate    = float(100 * (stock_meals>0).sum() / len(go))
    else:
        waste_per_100, stock_rate = np.nan, np.nan

    rows.append({
        "school_name": sch, "session": ses,
        "served_wmape": served_wmape,
        "cpm_mae": cpm_mae,
        "wastecost_mae": wastecost_mae,
        "waste_per_100_implied": waste_per_100,
        "stockout_day_rate_implied": stock_rate
    })

metrics = pd.DataFrame(rows).sort_values(["session","school_name"])
print("Rows in metrics:", len(metrics))  # expect ~374

result = pd.DataFrame(rows).sort_values(["session","school_name"])
print("Rows in metrics:", len(result))

result.to_csv("/content/drive/MyDrive/Capstone Project/Data/preprocess Data/baseline_backtest.csv", index=False)